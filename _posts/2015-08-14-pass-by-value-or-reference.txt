---
layout: post
title: 传值和传引用
categories: grammer
---

##传值和传引用

####Comparison between pass-by-value and pass-by-reference on Java and C++

Effective C++ 3th的条款20指出
> Prefer pass-by-reference to const to pass-by-value


读到这里会觉得Java在设计时把pass-by-value去掉了，剩下了the part of most effective。

不过呢，Java实际只有pass-by-value，只传递了指针的值,几乎等价于对象的pass-by-reference。

那没有真正的pass-by-reference，Java是不是少了什么？

{% highlight java %}
public class JPassByValue {
	
	public static void main(String[] args) {
		String s = "是call-by-value";
		changeString(s);
		System.out.println(s);
	}

	public static void changeString(String s) {
		s = "是call-by-reference";
	}
}
{% endhighlight %}

这个函数当然改变不了外部的s，结果是"是call-by-value"。也就是说，因为pass-by-value的关系，这个指针s所指向的东西是不会变的。

那么，C++的call-by-reference！虽然结果是"是call-by-reference"，但这绝不是因为传递进去的引用就指向了另外一个对象。

{% highlight c %}
void changeString(std::string& s) {
	std::cout << "旧string：" << &s << std::endl;
	std::string sp = "是call-by-reference";
	std::cout << "新string：" << &sp << std::endl;
	s = sp;  //这是一个copy assignment，而不是Java里指针的赋值
}

int main() {
	std::string s = "是call-by-value";
	std::cout << "初始string：" << &s << std::endl;
	changeString(s);
	std::cout << s.c_str() << std::endl;
	std::cout << "完结string：" << &s << std::endl;
	return 0;
}
{% endhighlight %}

结果是这样的：

![pass-by-reference](http://pic.yupoo.com/tan91319/ESp46vmv/medish.jpg)

所以地址还是没变，所以根本毫无区别。(ಥ_ಥ)
这是因为**一个引用在初始化后，是不能指向另外一个对象的。**

有没有一种“唐僧不能用吃自己肉的方法来长生不老，是因为，他是和尚只能吃素”的缜密感呢？

所以感觉Java在参数传递的设计上，确实已经most effective了。至于，之所以第二个例子里，内容被改变，完全是因为那是一个copy assignment运算，而不是简单的指针赋值。另外，一般的对象还好，在Java里要对String做这种操作是不行的，不提供呢。

说起来String是可以拓展成可变对象的，就算final加到所有成员上，也不代表那个char[]里的值不可以改，另外在class上加final是限制继承，而不表示对象不可变。C++倒是无法限制一个对象被继承。